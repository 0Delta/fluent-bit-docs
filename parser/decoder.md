# Parser Decoders

There are certain cases where the log messages being parsed contains encoded data, a typical use case can be found in containerized environments with Docker: application logs it data in JSON format but becomes an escaped string,  Consider the following example

Original message generated by the application:

```
{"status": "up and running"}
```

Then the Docker log message become encapsulated as follows:

```
{"log":"{\"status\": \"up and running\"}\r\n","stream":"stdout","time":"2018-03-09T01:01:44.851160855Z"}

```

as you can see the original message is handled as a escaped string. Ideally in Fluent Bit we would like to keep having the original structured message and not a string.

## Getting Started 

Decoders are a built-in feature available through the Parsers file, each Parser definition can optionally set one or multiple decoders. Our pre-defined Docker Parser have the following definition:

```
[PARSER]
    Name         docker
    Format       json
    Time_Key     time
    Time_Format  %Y-%m-%dT%H:%M:%S.%L
    Time_Keep    On
    # Command    |  Decoder | Field | Optional Action   |
    # ===========|==========|=======|===================|
    Decode_Field    json       log    try_next
    Decode_Field    escaped    log
```

Each line in the parser with a key _Decode_Field_  instruct the parser to apply a specific decoder on a given field, optionally it offer the option to take an extra action if the decoder cannot succeed. 

### Decoders

| Name    | Description                                                  |
| ------- | ------------------------------------------------------------ |
| json    | handle the field content as a JSON map. If it find a JSON map it will replace the content with a structured map. |
| escaped | decode an escaped string.                                    |

### Optional Actions

By default if a decoder fails to decode the field, it will pack the raw message without any changes. Optionally an action can be defined when that exception happens. If the action __try_next__ was defined, it will use the next decoder available.

